#pragma kernel RayTrace

#define MIN_T .001
#define MAX_T 999.  

RWTexture2D<float4> RenderOut;

float uWidth;
float uHeight;
float uRatio;

struct Ray
{
	float3 origin;
	float3 direction;

	float3 PointAtParameter(float t);
};

float3 Ray::PointAtParameter(float t)
{
	return origin + direction * t;
}

Ray GetRay(float3 origin, float3 direction)
{
	Ray r;

	r.origin = origin;
	r.direction = direction;

	return r;
}

struct HitRecord
{
	bool isHit;

	float tMin;
	float tMax;
	
	float t;
	float3 p;
	float3 normal;
};

HitRecord GetHitRecord(float tMin, float tMax)
{
	HitRecord h;

	h.isHit = false;

	h.tMin = tMin;
	h.tMax = tMax;

	h.t = tMax;

	// just random values for debugging
	h.p = float3(0., 1., 0.);
	h.normal = float3(1., 0., 0.);

	return h;
}

struct Sphere
{
	float3 center;
	float radius;

	void Intersect(Ray r, inout HitRecord rec);
};

Sphere GetSphere(float3 center, float radius)
{
	Sphere s;
	
	s.center = center;
	s.radius = radius;

	return s;
}

void Sphere::Intersect(Ray r, inout HitRecord rec)
{
	float3 oc = r.origin - center;
	float a = dot(r.direction, r.direction);
	float b = dot(oc, r.direction);
	float c = dot(oc, oc) - radius * radius;
	float discriminant = b * b - a * c;

	if (discriminant > 0)
	{
		float temp = (-b - sqrt(discriminant)) / a;

		if (temp < rec.tMax && temp > rec.tMin)
		{
			rec.isHit = true;
			rec.tMax = temp;
			
			rec.t = temp;
			rec.p = r.PointAtParameter(temp);
			rec.normal = (rec.p - center) / radius;

			return;
		}

		temp = (-b + sqrt(discriminant)) / a;

		if (temp < rec.tMax && temp > rec.tMin)
		{
			rec.isHit = true;
			rec.tMax = temp;
			
			rec.t = temp;
			rec.p = r.PointAtParameter(temp);
			rec.normal = (rec.p - center) / radius;

			return;
		}
	}

	return;
}

float3 RenderScene(Ray r)
{
	Sphere sphere_a = GetSphere(float3(0, 0, -1.), .5);
	Sphere sphere_b = GetSphere(float3(0, -100.5, -1.), 100.);

	HitRecord hitRecord = GetHitRecord(MIN_T, MAX_T);

	sphere_a.Intersect(r, hitRecord);
	sphere_b.Intersect(r, hitRecord);

	if (hitRecord.isHit)
	{
		float3 hitNormal = .5 * (hitRecord.normal + 1.);

		return hitNormal;
	}
	else
	{
		float gradient = .5 * (r.direction.y + 1.);
		float3 sky = (1. - gradient) * float3(1., 1., 1.) + gradient * float3(.5, .7, 1.);

		return sky;
	}
}

[numthreads(8,8,1)]
void RayTrace(uint3 id : SV_DispatchThreadID)
{
	float2 uv = float2((float)id.x / uWidth, (float)id.y / uHeight);
	float3 pixel = float3((uv - .5) * 2. * float2(uRatio, 1.), 0.);

	float3 origin = float3(0., 0., 1.);
	float3 direction = normalize(pixel - origin);
	
	Ray r = GetRay(origin, direction);

	float3 col = RenderScene(r);

	RenderOut[id.xy] = float4(col, 1.);
}
